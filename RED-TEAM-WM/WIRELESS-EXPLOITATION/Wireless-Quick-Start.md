# (1) Basic Network and Host Enumeration

This section outlines some initial commands that can be used to gather basic information about the local system and network during wireless enumeration.

## Basic System Information

1.  **`whoami`**
    * **Description:** This command displays the username of the current user.
    * **Command:**
        ```bash
        whoami
        ```

2.  **`ip a`**
    * **Description:** This command displays information about the network interfaces, including the current IP address.
    * **Command:**
        ```bash
        ip a
        ```

3.  **`ip neigh`**
    * **Description:** This command displays information about neighboring reachable IP addresses.
    * **Command:**
        ```bash
        ip neigh
        ```

## ARP (Address Resolution Protocol) Scans

ARP scans are used to identify devices connected to the local network by examining the ARP table.

1.  **`arp -an` or `arp -a`**
    * **Description:** This command is a fast survey tool that outputs the ARP table, showing IP addresses and their associated MAC addresses. It may also output hostnames if available.
    * **Command:**
        ```bash
        arp -an
        ```
        or
        ```bash
        arp -a
        ```

2.  **`sudo arp-scan -l`**
    * **Description:** This command performs a local ARP scan on the local network. It requires root privileges (`sudo`).
    * **Command:**
        ```bash
        sudo arp-scan -l
        ```

3.  **`sudo arp-scan <IP address/XX>`**
    * **Description:** This command allows you to specify the MAC address connections associated with a particular IP address or network range (using CIDR notation like `/24`). It also requires root privileges (`sudo`).
    * **Command:**
        ```bash
        sudo arp-scan <IP address/XX>
        ```

## Network Mapping

Network mapping involves discovering and identifying devices and their characteristics on a network.

1.  **Ping Sweep**
    * **Description:** A ping sweep sends ICMP echo requests to a range of IP addresses to identify active hosts.
    * **Command:**
        ```bash
        for i in {subnet#..subnet#}; do (ping -c 1 XX.XX.XX.$i | grep "bytes from" &); done | awk '{print $X}'
        ```
        * **Note:** Replace `subnet#..subnet#` with the desired IP address range and `XX.XX.XX` with the base subnet. The `awk '{print $X}'` part might need adjustment depending on the desired output field (e.g., `$4` for the IP address).

2.  **netdiscover**
    * **Description:** `netdiscover` is a tool that actively probes the network to discover connected devices and can provide continuous updates.
    * **Commands:**
        1.  **`sudo netdiscover -r <IP address/>`**
            * **Description:** Performs a scan on the specified IP address range.
            * **Command:**
                ```bash
                sudo netdiscover -r <IP address/>
                ```
        2.  **`sudo netdiscover -f -r <IP.address> -c 3 -i <interface/>`**
            * **Description:** Performs a scan with specific options:
                * `-f`: Enables fast mode.
                * `-r <IP.address>`: Specifies the IP address range to scan.
                * `-c 3`: Sends 3 ARP requests per host.
                * `-i <interface/>`: Specifies the network interface to use (e.g., `wlan0`).
            * **Command:**
                ```bash
                sudo netdiscover -f -r <IP.address> -c 3 -i <interface/>
                ```

3.  **fping**
    * **Description:** `fping` is another tool used to identify live hosts, similar to a ping sweep. However, it might not be effective against networks with firewalls that block ICMP requests.
    * **Command:**
        ```bash
        fping -a -r 1 -n -g <IP.address> 2> /dev/null
        ```
        * **Note:**
            * `-a`: Shows hosts that are alive.
            * `-r 1`: Sends 1 retry if a host doesn't respond initially.
            * `-n`: Displays output in a non-numeric format.
            * `-g <IP.address>`: Specifies the network address to scan.
            * `2> /dev/null`: Redirects error messages to null.

4.  **nmap (Network Mapper)**
    * **Description:** `nmap` is a powerful and versatile network scanning tool used for various purposes, including host discovery and service identification. Refer to the nmap Cheat Sheet for more options.
    * **Commands:**
        1.  **`nmap -sT -Pn -T4 <IP.address>`**
            * **Description:**
                * `-sT`: Performs a TCP connect scan (requires a full TCP handshake).
                * `-Pn`: Skips host discovery (assumes the target is up).
                * `-T4`: Specifies a timing template (aggressive, but generally reliable on good networks).
            * **Command:**
                ```bash
                nmap -sT -Pn -T4 <IP.address>
                ```
        2.  **`nmap -Pn -sV -vvv -T4 <IP.address> -pXX`**
            * **Description:**
                * `-Pn`: Skips host discovery.
                * `-sV`: Performs service version detection.
                * `-vvv`: Enables very verbose output.
                * `-T4`: Specifies the timing template.
                * `-pXX`: Scans only port XX (replace XX with the port number).
            * **Command:**
                ```bash
                nmap -Pn -sV -vvv -T4 <IP.address> -pXX
                ```
        3.  **`nmap -A <IP address/> -p-`**
            * **Description:**
                * `-A`: Enables aggressive scan options, including OS detection, version detection, script scanning, and traceroute.
                * `<IP address/>`: Specifies the target IP address or network range.
                * `-p-`: Scans all 65535 ports.
            * **Command:**
                ```bash
                nmap -A <IP address/> -p-
                ```
        4.  **`nmap -Pn --script=`**
            * **Description:** Executes NSE (Nmap Scripting Engine) scripts.
            * **Example:**
                ```bash
                nmap -Pn --script=smb-os-discovery <IP address>
                ```
            * **Script Location:** `/usr/share/nmap/scripts` (This is the default directory where nmap scripts are located).

## Viewing Source Pages

These techniques are used to gather information from the source code and configuration files of web applications.

1.  **`href` = Links**
    * **Description:** Examining the `href` attributes in the HTML source code can reveal internal links and potentially hidden pages or directories.

2.  **`robots.txt`**
    * **Description:** The `robots.txt` file is a standard text file used by websites to communicate to web robots (crawlers) which areas of the website should not be processed or scanned. It can sometimes reveal interesting or restricted paths. Access it by appending `/robots.txt` to the website's URL (e.g., `http://example.com/robots.txt`).

3.  **`curl cheat.sh/<command/>`**
    * **Description:** This command uses the `curl` utility to quickly retrieve cheat sheets for various commands from the `cheat.sh` service. Replace `<command/>` with the specific command you need help with (e.g., `curl cheat.sh/nmap`).
    * **Command:**
        ```bash
        curl cheat.sh/<command/>
        ```

# (2) Basic Wireless Network and Host Enumeration

This section covers commands related to setting up a Wi-Fi connection, troubleshooting connection issues, scanning the local network (LAN), and initial enumeration.

## Creation of Passphrase and WPA Conf File

1.  **Creating the `wpa_supplicant.conf` File**
    * **Description:** This command generates the necessary configuration to connect to a Wi-Fi network using WPA/WPA2 encryption.
    * **Command:**
        ```bash
        sudo wpa_passphrase 'SSID' 'password' >> /etc/wpa_supplicant/wpa_supplicant.conf
        ```
        * **Note:** Replace `'SSID'` with the target network's SSID and `'password'` with its password (gathered from further investigation and intel). The `>>` appends the output to the configuration file.

## Verify Conf File is Correct

1.  **Viewing the `wpa_supplicant.conf` File**
    * **Description:** This command opens the configuration file in the `nano` text editor to verify its contents.
    * **Command:**
        ```bash
        sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
        ```
        * **Note:** For hidden SSIDs, ensure the line `scan_ssid=1` is present in the configuration file.

## Connect to WiFi (Once in Range)

1.  **Connecting to the Network**
    * **Description:** This command uses `wpa_supplicant` to attempt to connect to the Wi-Fi network defined in the configuration file.
    * **Command:**
        ```bash
        sudo wpa_supplicant -B -c /etc/wpa_supplicant/wpa_supplicant.conf -i <interface (wlan0)>
        ```
        * **Note:** Replace `<interface (wlan0)>` with the appropriate wireless interface name (e.g., `wlan0`, `wlp3s0`). The `-B` flag runs `wpa_supplicant` in the background.

## TROUBLESHOOTING

1.  **Checking `wpa_supplicant` Processes**
    * **Description:** This command lists processes that contain "wpa" in their name, which can help identify if `wpa_supplicant` is running.
    * **Command:**
        ```bash
        ps aux | grep wpa
        ```

2.  **Killing a `wpa_supplicant` Process**
    * **Description:** If `wpa_supplicant` is stuck or needs to be restarted, this command can be used to terminate its process.
    * **Command:**
        ```bash
        sudo kill -9 <PID>
        ```
        * **Note:** Replace `<PID>` with the process ID of the `wpa_supplicant` process you want to terminate (found using the `ps aux | grep wpa` command). The `-9` flag sends a SIGKILL signal, forcing immediate termination.

3.  **Managing the Network Interface**
    * **Description:** These commands can be used to bring the network interface up or down, which can sometimes resolve connection issues.
    * **Commands:**
        ```bash
        sudo <interface> down
        ```
        or
        ```bash
        sudo <interface> up
        ```
        * **Note:** Replace `<interface>` with the appropriate interface name (e.g., `wlan0`).

## Check for Successful Connection

1.  **Checking Wireless Interface Configuration**
    * **Description:** This command displays information about the wireless interface, including its status and associated access point.
    * **Command:**
        ```bash
        iwconfig
        ```

2.  **Checking Interface Link Status**
    * **Description:** This command shows the status of the specified network interface, including whether it's up or down.
    * **Command:**
        ```bash
        ip link show <interface (wlan0)>
        ```
        * **Note:** Replace `<interface (wlan0)>` with the appropriate interface name.

## Manual Request of IP address

1.  **Requesting an IP Address via DHCP**
    * **Description:** This command manually requests an IP address from the DHCP server on the network for the specified interface.
    * **Command:**
        ```bash
        sudo dhclient <interface (wlan0)>
        ```
        * **Note:** Replace `<interface (wlan0)>` with the appropriate interface name.

2.  **Checking Interface Configuration (Legacy)**
    * **Description:** This command displays detailed information about network interfaces, including the assigned IP address.
    * **Command:**
        ```bash
        ifconfig
        ```

3.  **Checking Interface Configuration (Modern)**
    * **Description:** This command displays information about network interfaces and can be used to find the assigned IP address.
    * **Command:**
        ```bash
        ip a | grep inet
        ```

## Scan LAN (Priv to Non-Priv)

This section covers scanning the local network for active hosts, starting with commands that might not require elevated privileges and then moving to those that do.

1.  **ARP Table Scan (Non-Privileged)**
    * **Description:** Displays the ARP table, showing locally connected devices.
    * **Command:**
        ```bash
        arp -a
        ```

2.  **Basic Ping Sweep (Non-Privileged)**
    * **Description:** Sends a single ping to each IP address in a specified range to identify active hosts.
    * **Command:**
        ```bash
        for i in {1..225}; do (ping -c 1 XX.XX.XX.$i) | grep 'bytes from' &); done
        ```
        * **Note:** Replace `XX.XX.XX` with the appropriate subnet. This example scans the typical range of `.1` to `.225`.

3.  **`fping` Scan (Non-Privileged)**
    * **Description:** Quickly pings a range of IP addresses to identify live hosts. May not work against firewalls blocking ICMP.
    * **Command:**
        ```bash
        fping -a -r 1 -n -g <IP address> 2>/dev/null
        ```
        * **Note:** Replace `<IP address>` with the base network address (e.g., `192.168.1.0`).

---

1.  **`arp-scan` (Privileged)**
    * **Description:** Performs an ARP scan on the local network using the specified interface. Requires root privileges.
    * **Command:**
        ```bash
        sudo arp-scan -l --interface=wlan0
        ```
        * **Note:** You might need to adjust the interface name if it's not `wlan0`.

2.  **`netdiscover` (Privileged)**
    * **Description:** Actively probes the network to discover connected devices. Requires root privileges.
    * **Command:**
        ```bash
        sudo netdiscover -r <IP address>
        ```
        * **Note:** Replace `<IP address>` with the target IP address range (e.g., `192.168.1.0/24`).

## Enumeration to Access IP address

These commands are used to gather more detailed information about specific IP addresses on the network, focusing on ports and services.

1.  **`nmap` Service Version Detection (Specific Port Range)**
    * **Description:** Scans the specified port range (2000-3000) on the target IP address and attempts to determine the service running on those ports.
    * **Command:**
        ```bash
        nmap -sV <IP address> -p2000-3000
        ```
        * **Note:** Replace `<IP address>` with the target IP address.

2.  **`nmap` Aggressive Scan (Specific Port Range)**
    * **Description:** Performs an aggressive scan on the specified port range (2000-3000), including OS detection, version detection, and script scanning.
    * **Command:**
        ```bash
        nmap -A <IP address> -p2000-3000
        ```
        * **Note:** Replace `<IP address>` with the target IP address.

3.  **`nmap` Comprehensive Scan (All Ports)**
    * **Description:** Scans all 65535 TCP ports on the target IP address, performs service version detection (`-sV`), uses a SYN stealth scan (`-sS`), and employs an aggressive timing template (`-T4`).
    * **Command:**
        ```bash
        nmap -p 1-65535 -sV -sS -T4 <IP>
        ```
        * **Note:** Replace `<IP>` with the target IP address.

## Forensic Investigation

These commands are related to basic forensic investigation techniques.

1.  **`steghide` Information**
    * **Description:** `steghide` is a steganography tool. This command attempts to retrieve information about hidden data within an image file.
    * **Command:**
        ```bash
        steghide info <image>
        ```
        * **Note:** Replace `<image>` with the path to the image file you want to analyze.

2.  **`exiftool` for Metadata**
    * **Description:** `exiftool` is a tool used to read and write metadata in various file formats. This command would typically be used to extract metadata from files (like images).
    * **Command:**
        ```bash
        exiftool <file>
        ```
        * **Note:** Replace `<file>` with the path to the file you want to examine the metadata of.


# (3) Wireless Enumeration Tools and Techniques (Continued)

This section covers various tools and techniques used in wireless enumeration, including setting up monitor mode, capturing wireless traffic, using Software Defined Radio (SDR), Digital Terrain Mapping, packet analysis, and more.

## AIRMON-NG

* **Description:** `airmon-ng` is a tool used to enable monitor mode on wireless network interfaces. Monitor mode allows the interface to capture all wireless traffic in the vicinity, regardless of the intended recipient.

* **Commands:**
    1.  **Check and Kill Conflicting Processes:**
        ```bash
        sudo airmon-ng check kill
        ```
        * **Description:** This command checks for processes that might interfere with monitor mode and prompts you to kill them.

    2.  **Start Monitor Mode:**
        ```bash
        sudo airmon-ng start <wlan#>
        ```
        * **Description:** This command puts the specified wireless interface (`<wlan#>`) into monitor mode. The interface name might change (e.g., to `wlan0mon`).
        * **Verification:**
            * **Check Interface Configuration:**
                ```bash
                iwconfig
                ```
                * **Description:** Verify that the interface now shows `Mode:Monitor`.
            * **Check Interface Link Status:**
                ```bash
                ip link show <wlan#>
                ```
                * **Description:** Confirm the status of the interface.

## AIRODUMP-NG OPTIONS

* **Description:** `airodump-ng` is a powerful tool for capturing raw 802.11 frames. It can display information about wireless networks (Access Points) and clients (Stations) in real-time, including details like SSID, BSSID, channel, encryption type, and signal strength.

* **Commands:**
    1.  **Capture on All Bands:**
        ```bash
        sudo airodump-ng --band abg -M <wlan#mon>
        ```
        * **Description:**
            * `--band abg` or `-b abg`: Specifies the bands to scan (a, b, g). This allows `airodump-ng` to cycle through all channels within the 2.4 GHz and 5 GHz frequency ranges.
            * `-M`: Resolves the Organizationally Unique Identifier (OUI) to display the manufacturer of the devices.
            * `<wlan#mon>`: The monitor mode interface (e.g., `wlan0mon`).

    2.  **Capture on a Specific Channel and Write to File:**
        ```bash
        sudo airodump-ng -c '#' -M <wlan#mon> -w <file>
        ```
        * **Description:**
            * `--channel #` or `-c '#'`: Sets the specific channel to monitor (replace `#` with the channel number).
            * `-M`: Resolves OUIs.
            * `<wlan#mon>`: The monitor mode interface.
            * `--write <file>` or `-w <file>`: Writes the captured data to a file (multiple files will be created with different extensions).

        * **Airodump-ng Options:**
            * `--channel n` (`-c '#'`) : Set the channel to monitor.
            * `--band n` (`-b abg`) : Search for signals on all supported bands (2.4 GHz and 5 GHz).
                * `abg`: Cycles through all channels in the 2.4 GHz and 5 GHz bands.
            * `--write` (`-w`) : Write captured data to the filesystem.
            * `--manufacturer` (`-M`) : Resolve OUIs to display device manufacturers.
            * `--gpsd`: Enable GPS service integration.
            * `--uptime` or `-U`: Display the uptime of the access points.

    3.  **Narrow Collection by BSSID:**
        ```bash
        sudo airodump-ng -c '#' --bssid <MAC address> -M <wlan#mon> -w <file>
        ```
        * **Description:** This command focuses the capture on a specific Access Point (WAP) identified by its MAC address (BSSID).
            * `--bssid <MAC>`: Filter capture based on the MAC address of the Access Point.
            * `--essid <SSID>`: Filter capture based on the SSID of the network.
            * `--encrypt <ENC>`: Filter capture based on the encryption type (e.g., WEP, WPA, WPA2).
            * `--essid-regex <regex>`: Filter SSIDs based on a regular expression for partial matching.
            * `-c '#'`: The channel of the target network.
            * `-M`: Resolves OUIs.
            * `<wlan#mon>`: The monitor mode interface.
            * `-w <file>`: Write captured data to a file.

        * **Interactive Airodump Options (While Running):**
            * `m`: Mark a selection in the output.
            * `Spacebar`: Pause the output.
            * `Tab`: Move over to select different columns for sorting or filtering.
            * Selecting `a`: Allows you to filter the display by Access Points, Stations (clients), or Acknowledgements.
            * Selecting `s`: Allows you to sort the displayed networks or clients by different criteria (e.g., signal strength, number of data packets).

## HACK RF (SDR - Software Defined Radio)

* **Description:** HackRF is an open-source SDR platform capable of transmitting and receiving radio signals from 1 MHz to 6 GHz. It can be used for monitoring and collecting a wide range of radio frequencies.

* **Commands and Usage:**
    1.  **Check HackRF Information:**
        ```bash
        hackrf_info
        ```
        * **Description:** Displays information about the connected HackRF device.

    2.  **CubicSDR:**
        * **Description:** A graphical software application commonly used with HackRF for visualizing and interacting with radio signals.
        * **Steps:**
            1.  Open CubicSDR.
            2.  Select **HackRF One** as the device.
            3.  Click **Start**.
            4.  Go to **Settings** and enable **Automatic Gain** initially to help identify signals.
            5.  Once a signal of interest is found, disable **Automatic Gain** to fine-tune the reception.

* **US Bands of Interest:**
    * 3-30MHz - HF Communications
    * 30-88MHz - Military Communications (MILCOM)
    * 88-108MHz - FM Broadcast (Radio Stations)
    * 108-118MHz - ATC Beacons (AM - Air Traffic Control)
    * 118-137MHz - ATC Communications (AM)
    * 144-148MHz - 2 Meter Amateur Band
    * 162.4–162.55MHz - NOAA Weather Beacons
    * 462-468MHz - FRS/GMRS Band (Family Radio Service/General Mobile Radio Service)

* **Devices of Interest (Frequencies):**
    * 315MHz - Tire Pressure Monitoring Systems (TPMS), Key Fobs
    * 300, 310, 315, 390MHz - Garage Door Openers
    * 433MHz - Temperature Sensors
    * 868MHz - European Sensors
    * 915MHz - ISM (Industrial, Scientific, and Medical) Test Equipment
    * 1090 MHz - ADS-B (Automatic Dependent Surveillance-Broadcast)

## KISMET

* **Description:** Kismet is a network detector, sniffer, and intrusion detection system. It works by passively collecting packets and identifying networks. It is particularly known for its digital terrain mapping capabilities and can optionally integrate with GPS for location tracking of discovered networks.

* **Important Notes:**
    1.  **Do NOT** put your wireless device in monitor mode before running Kismet. Kismet typically handles this itself.
    2.  **Kill Existing Kismet Processes:**
        ```bash
        sudo killall -9 kismet
        ```

* **Configuration:**
    1.  **Download `kismet_site.conf`:**
        * **Description:** This configuration file is used to store the details of the networks you've gathered for later analysis. You can often find example configurations online (e.g., from GitHub repositories like MuppetPant).
        * **Command (Example):**
            ```bash
            wget <kismet.conf URL from MuppetPant GitHub>
            ```

    2.  **Edit `kismet.conf`:**
        * **Description:** Modify the main Kismet configuration file to enable your wireless and optionally Bluetooth interfaces.
        * **Command:**
            ```bash
            sudo nano /etc/kismet/kismet.conf
            ```
        * **Configuration Changes:**
            * **Bluetooth:** Uncomment the line starting with `source=hci0...` to enable Bluetooth monitoring.
            * **Wi-Fi:** Uncomment the line starting with `source=wlan<#>...` and replace `<#>` with your wireless interface name (e.g., `wlan0`).

    3.  **Copy `kismet_site.conf`:**
        ```bash
        sudo cp kismet_site.conf /etc/kismet/
        ```

* **GPS Integration (Optional):**
    1.  **Plug in GPS Puck.**
    2.  **Check for Attached GPS Device:**
        ```bash
        sudo dmesg | grep attached
        ```
        * **Description:** This command will output information about newly attached devices, helping you identify the device name for your GPS puck (e.g., `ttyUSB0`).

    3.  **Start `gpsd` (GPS Daemon):**
        ```bash
        sudo gpsd /dev/<device that is attached>
        ```
        * **Example:**
            ```bash
            sudo gpsd /dev/ttyUSB0
            ```
        * **Description:** `gpsd` is a service daemon that makes GPS receiver data available to applications.

    4.  **Verify Wireless Interface:**
        ```bash
        iwconfig
        ```

* **Start Kismet:**
    1.  **Set Execute Permissions (if needed):**
        ```bash
        chmod 700 kismet
        ```

    2.  **Run Kismet:**
        ```bash
        sudo kismet
        ```

    3.  **Access Web Interface:** Open your web browser and navigate to `localhost:2501`.

* **Kismet KML File (GPS Visualization):**
    1.  **Convert Kismet Database to KML:**
        ```bash
        sudo kismetdb_to_kml --in <file.kismet> --out <file.kml>
        ```
        * **Description:** This command converts the Kismet database file (`<file.kismet>`) to a KML (Keyhole Markup Language) file that can be viewed in applications like Google Earth.

    2.  **Install `gpsprune` (Optional):**
        ```bash
        sudo apt install gpsprune
        ```
        * **Description:** `gpsprune` is a tool for viewing and editing GPS data, including KML files.

    3.  **Open KML File with `gpsprune` (Optional):**
        ```bash
        gpsprune <file.kml>
        ```

* **Kismet PCAP-NG:**
    1.  **Convert Kismet Database to PCAP-NG:**
        ```bash
        sudo kismetdb_to_pcap --in <file.kismet> --out <drive2.pcap-ng>
        ```
        * **Description:** This command converts the Kismet database file to a `pcap-ng` format, which can be opened and analyzed in Wireshark.

## WIRESHARK FILTERS

* **Description:** Wireshark filters are powerful tools used to analyze captured network traffic by specifying criteria to display or isolate specific packets.

* **Common Filters:**
    * `wlan.ssid==#SSID`: Filter by a specific SSID (replace `#SSID` with the target SSID).
    * `wlan.bssid==#BSSID`: Filter by a specific BSSID (replace `#BSSID` with the target MAC address).
    * `wlan.ds.current_channel==#BSSID channel`: Filter by the channel of a specific BSSID.
    * `wlan.ra==#Receive Address`: Filter by the receiver MAC address.
    * `wlan.ta==#Transmit Address`: Filter by the transmitter MAC address.
    * `wlan.da==#Destination Address`: Filter by the destination MAC address.
    * `wlan.sa==#Source Address`: Filter by the source MAC address.
    * `wlan.addr==<MAC address>`: Filter by any of the MAC addresses (receiver, transmitter, destination, or source).
    * `frame contains "XXX"`: Filter packets whose raw data contains the string "XXX".
    * `wlan.ssid contains "XXX"`: Filter packets where the SSID contains the string "XXX".
    * `eapol`: Filter EAP over LAN (Extensible Authentication Protocol over LAN) packets, often used in WPA/WPA2 handshakes.
    * `wlan.fc.type_subtype == x`: Filter by specific 802.11 frame types and subtypes (replace `x` with the corresponding number):
        * `0`: Association Request
        * `1`: Association Response
        * `4`: Probe Request
        * `5`: Probe Response
        * `8`: Beacon
        * `10`: Disassociate
        * `11`: Authentication
        * `12`: Deauthenticate
        * `40`: QoS Data

## WIRESHARK PCAP CARVING

* **Description:** PCAP carving involves extracting specific packets of interest from a larger capture file based on certain criteria.

* **Example Filter:**
    ```
    (wlan.bssid==<BSSID> && wlan.fc.type_subtype==8) || eapol
    ```
    1.  **Description:** This filter selects packets that are either Beacon frames from a specific BSSID (replace `<BSSID>` with the target MAC address) or EAPOL packets (used for capturing WPA/WPA2 handshakes).
    2.  **Exporting Packets:** To save these filtered packets:
        * Go to **File** > **Export Specified Packets**.
        * **Add Filename** for the exported PCAP.
        * Toggle the option to export **Capture** or **Displayed** packets (choose **Displayed** if you have applied the filter).

## CHAINING WIRESHARK FILTERS

* **Description:** You can combine multiple Wireshark filters using logical operators like `&&` (AND) and `||` (OR) to create more specific filtering criteria.

* **Examples:**
    1.  `frame contains "XXX" && wlan.fc.type_subtype == 4`: Filter for Probe Request frames that also contain the string "XXX" in their data.
    2.  `frame contains "XXX" || wlan.fc.type_subtype == 8`: Filter for packets that either contain the string "XXX" or are Beacon frames.

## WIRESHARK FRAME INFO

* **Description:** Understanding the different parts of a Wireshark frame can provide valuable insights into wireless communication.

* **Key Frame Sections:**
    1.  **Radio Tap Header:** Contains information about the physical layer, such as signal strength and data rate.
    2.  **Antenna Signal:** Indicates the strength of the received signal.
    3.  **IEEE 802.11 Subtype:** Specifies the type of 802.11 frame (e.g., Beacon, Probe Request, Data).
    4.  **Frame Control Field > Flags:** Contains various flags indicating the status and characteristics of the frame:
        * **DS Status:** Distribution System status (To DS, From DS, etc.).
        * **Retry:** Indicates if this frame is a retransmission.
        * **Protected flag:** Indicates if the frame payload is encrypted.
    5.  **Frame Control > Flags:** (Likely meant to refer to address fields)
        * **Receiver Address (RA):** The immediate receiver of the frame.
        * **Destination Address (DA):** The ultimate destination of the frame.
        * **Transmitter Address (TA):** The device that transmitted the frame.
        * **Source Address (SA):** The original source of the frame.
    6.  **IEEE 802.11 Wireless Management:** Contains management-related information for wireless networks.
        * **Fixed Parameters > Time Stamp:** A timestamp broadcast by Access Points in Beacon frames.
            * **Calculation:** Copy the timestamp value and perform the following calculations:
                1.  `XXX / 1000000 = seconds`
                2.  `seconds / 60 = minutes`
                3.  `minutes / 60 = hours`
                4.  `hours / 24 = days`
        * **Capabilities:** Information about the features supported by the Access Point.
            * **ESS capabilities:** Indicates an Infrastructure network.
            * **Privacy:** Indicates if encryption (like WEP or WPA/WPA2) is enabled.
    7.  **IEEE 802.11 Wireless Management > Tagged Parameter Set: "SSID-value"**: The actual name of the wireless network (SSID).
    8.  **IEEE 802.11 Wireless Management > Tagged Parameters > HT Capabilities (802.11n D1.10):** Information about High-Throughput (802.11n) capabilities.
        * **HT Capabilities Info > HT Support Channel Width:** Indicates the supported channel width (e.g., 20 MHz or 40 MHz).
        * **HT Information:** Contains further details about HT operation.
        * **HT Information > Primary Channel:** The primary channel used by the Access Point.
        * **HT Information > HT Information Subset.**
        * **Tagged Parameters > Tag: RSN Information:** Information about Robust Security Network (WPA2).
            * **Group Cipher Suite > Auth Key Management:** Specifies the authentication and key management protocol (e.g., PSK).
            * **RSN Capabilities.**
        * **Tagged Parameters > Tag: VHT Operation:** Information about Very High Throughput (802.11ac) operation.
            * **VHT Operation Info > Channel Width, Channel Center:** Details about the channel width and center frequency for 802.11ac.
        * **Tag: VHT Capabilities:** Capabilities related to 802.11ac.
            * **Supported Channel, Short GI...**

## WIRESHARK CONFIGURATION

* **Pass Keys (for decryption):**
    1.  Press `Ctrl + Shift + P` to open Wireshark Preferences.
    2.  Navigate to **Protocols** > **IEEE 802.11**.
    3.  Go to the **Decryption keys** section and click **Edit**.
    4.  Add the SSID and corresponding password (key) for networks you want to decrypt.

* **Name Resolution of BSSIDs:**
    1.  Go to **View** > **Name Resolution**.
    2.  Ensure **Resolve MAC addresses** is checked to see if Wireshark can resolve BSSIDs to known vendor names. You can also enable other name resolution options as needed.

* **Wireless Toolbar:**
    1.  Go to **View** and select **Wireless Toolbar** to enable a toolbar with quick access to wireless-related settings, including decryption keys.

## TSHARK

* **Description:** TShark is a command-line packet analyzer that is part of the Wireshark distribution. It is useful for capturing and filtering network traffic directly from the terminal, especially in scenarios where a graphical interface is not desired or practical.

* **Commands:**
    1.  **Kill Conflicting Processes (if using monitor mode):**
        ```bash
        sudo airmon-ng check kill
        ```

    2.  **Start Monitor Mode (if needed for wireless capture):**
        ```bash
        sudo airmon-ng start <interface> <channel#>
        ```
        * **Description:** This command puts the specified wireless interface into monitor mode and optionally sets it to a specific channel. This is useful to verify that you are on the correct interface and channel based on a previously captured PCAP file.

    3.  **Read from a PCAP File:**
        ```bash
        tshark -r <file.pcap>
        ```
        * **Description:** Analyzes the packets in the specified PCAP file.

    4.  **Capture to a PCAP File:**
        ```bash
        tshark -i <interface> -w <file.pcap>
        ```
        * **Description:** Captures live traffic from the specified interface (`<interface>`) and saves it to the specified PCAP file.

    5.  **Capture a Limited Number of Frames:**
        ```bash
        tshark -i <interface> -w <file.pcap> -c 20
        ```
        * **Description:** Captures only 20 frames and then terminates the capture. The `-c` option specifies the number of frames to capture.

    6.  **Capture with Autostop Conditions:**
        ```bash
        tshark -i <interface> -w <output.pcap> -a <key:value>
        ```
        * **Description:** Captures traffic with defined autostop conditions.
            * `duration:nn`: Stop capture after `nn` seconds (e.g., `duration:20`).
            * `filesize:xx`: Stop capture when the file size reaches `xx` kilobytes (e.g., `filesize:1000`).

    7.  **Fetch Filtering (Capture Filter) - Beacon Frames Only:**
        ```bash
        tshark -i <interface> -f "wlan type mgt subtype beacon" -w <file.cap>
        ```
        * **Description:** Uses the `-f` option to apply a capture filter, capturing only 802.11 management frames with the subtype "beacon".

    8.  **Fetch Filtering (Capture Filter) - Probe Requests Only:**
        ```bash
        tshark -i <interface> -f "wlan type mgt subtype probe-req" -w <file.cap>
        ```
        * **Description:** Captures only 802.11 management frames with the subtype "probe-req" (probe requests).

    9.  **Yank Filtering (Display Filter) - After Capture:**
        ```bash
        tshark -r <file.pcap> -Y "<wireshark filter>"
        ```
        * **Description:** Applies a Wireshark display filter (`-Y`) to a previously captured PCAP file. For example, `wlan.fc.type_subtype==8` will display only Beacon frames.

    10. **Output Formatting (Extract Specific Fields):**
        ```bash
        tshark -r <file.pcap> -Y "wlan.fc.type_subtype==8" -T fields -e wlan.bssid -e wlan.ssid
        ```
        * **Description:** Extracts specific fields from the captured packets.
            * `-T fields`: Specifies the output format as fields.
            * `-e <value>`: Specifies the field to extract (e.g., `wlan.bssid`, `wlan.ssid`, `wlan.sa`, `wlan.ds.current_channel`).

    11. **Output to File and Decode (Example):**
        ```bash
        tshark -r <file.pcap> -Y "wlan.fc.type_subtype==8" -T fields -e wlan.bssid -e wlan.ssid > file_encoded.txt
        ```
        * **Description:** Saves the extracted BSSIDs and SSIDs to a text file. You might then use a custom script (`decode_script`) to further process or decode this information (e.g., decrypting encrypted SSIDs if possible).

## BLUE HYDRA

* **Description:** Blue Hydra is a tool used for collecting and detecting Bluetooth signals. It can help identify nearby Bluetooth devices and gather information about them.

* **Installation:**
    ```bash
    sudo apt install bluez bluez-test-scripts python3-bluez python3-dbus libsqlite3-dev ubertooth ruby-dev bundler
    git clone [https://github.com/ZeroChaos-/blue_hydra.git](https://github.com/ZeroChaos-/blue_hydra.git)
    cd blue_hydra/
    bundle install
    cd bin/
    ```

* **Collecting Bluetooth Signals:**
    ```bash
    sudo ./blue_hydra
    ```
    * **Description:** This command starts Blue Hydra, which will scan for Bluetooth devices and store the collected information in a `.db` file (e.g., `bluehydra.db`).

* **Post-Operation Analysis:**
    ```bash
    sudo sqlitebrowser <file.db>
    ```
    * **Description:** Use a SQLite browser to open and analyze the collected data in the `.db` file.
    * **Example:**
        1.  Browse the data for MAC addresses.
        2.  Copy all the MAC addresses.
        3.  Use `nano -l loc1.txt` to create a text file and paste the MAC addresses for further investigation.
    * **Cleanup:**
        ```bash
        rm bluehydra.db
        ```
        * **Description:** Remove the database file after analysis if needed.

## BLUE_SONAR

* **Description:** Blue Sonar is a tool used for active collection of information on specific Bluetooth devices (BSSIDs) that you might have identified using tools like Blue Hydra.

* **Installation:**
    ```bash
    git clone [https://github.com/ZeroChaos-/blue_sonar.git](https://github.com/ZeroChaos-/blue_sonar.git)
    ```

* **Usage:**
    ```bash
    ./blue_sonar --target <TARGET BD_ADDR> --sleep <sleep_period> --adapter <adapter>
    ```
    * `--target` or `-t`: Specifies the target Bluetooth device MAC address (`TARGET BD_ADDR`).
    * `--sleep` or `-s`: Sets the sleep period between scans (e.g., `0.25` seconds).
    * `--adapter` or `-i`: Specifies the Bluetooth adapter to use (e.g., `hci0`).

* **Example:**
    ```bash
    sudo ./blue_sonar -t 18:F1:D8:DD:62:59 -s .25 -i hci0
    ```

## MERGECAP

* **Description:** `mergecap` is a command-line tool from the Wireshark suite used to merge multiple packet capture files into a single file.

* **Usage:**
    ```bash
    mergecap -w <output_file.pcap> <input1.pcap> <input2.pcap> <input3.pcap> ...
    ```
    * `-w <output_file.pcap>`: Specifies the name of the output merged PCAP file.
    * `<input1.pcap>`, `<input2.pcap>`, `<input3.pcap>`: The names of the input PCAP files to be merged. You can include multiple input files.

## EDITCAP

* **Description:** `editcap` is another command-line tool from the Wireshark suite used for editing packet capture files. It can be used to remove packets, split files, or limit the number of packets.

* **Usage (Cutting up a PCAP by Count):**
    ```bash
    editcap -c <#> <input.pcap> <output.pcap>
    ```
    * `-c <#>`: Specifies the number of packets to keep in the output file. If the input file has more than this number, the output file will be truncated.

## AIRDECAP-NG

* **Description:** `airdecap-ng` is a tool from the Aircrack-ng suite used to decrypt WPA/WPA2 and WEP encrypted packet capture files.

* **WPA/WPA2 Decryption:**
    ```bash
    airdecap-ng -e '<SSID>' -p '<passphrase>' <file.pcap>
    ```
    * `-e '<SSID>'`: Specifies the SSID of the network.
    * `-p '<passphrase>'`: Specifies the passphrase (password) of the network.
    * `<file.pcap>`: The captured PCAP file containing the encrypted traffic.

* **WEP Decryption:**
    ```bash
    airdecap-ng -w <WEPKEY> <file.pcap>
    ```
    * `-w <WEPKEY>`: Specifies the WEP key used to encrypt the traffic.
    * `<file.pcap>`: The captured PCAP file.

## MAC ADDRESS SPOOFING

* **Note:** It's generally recommended to put your wireless interface into monitor mode *before* attempting to spoof the MAC address.

* **Spoofing (Living Off The Land - Manual Method 1):**
    1.  Bring the interface down:
        ```bash
        sudo ifconfig <interface#> down
        ```
    2.  Set the new MAC address:
        ```bash
        sudo ifconfig <interface#> hw ether <spoofed MAC address>
        ```
    3.  Bring the interface up:
        ```bash
        sudo ifconfig <interface#> up
        ```
    4.  Release the current IP address:
        ```bash
        sudo dhclient -r
        ```
    5.  Request a new IP address with the spoofed MAC:
        ```bash
        sudo dhclient <interface#>
        ```
        * **Description:** This process might enable the device to obtain a different IP address and store the spoofed MAC address in the router's ARP table.

* **Spoofing (Living Off The Land - Manual Method 2):**
    1.  Bring the interface down:
        ```bash
        sudo ip link set <interface#> down
        ```
    2.  Set the new MAC address:
        ```bash
        sudo ip link set <interface#> address <spoofed MAC address>
        ```
    3.  Bring the interface up:
        ```bash
        sudo ip link set <interface#> up
        ```
    4.  Release the current IP address:
        ```bash
        sudo dhclient -r
        ```
    5.  Request a new IP address with the spoofed MAC:
        ```bash
        sudo dhclient <interface#>
        ```

* **MAC Changer (Automated Tool):**
    1.  Bring the interface down:
        ```bash
        sudo ip link set <interface> down
        ```
    2.  Use the `macchanger` tool with various options:
        ```bash
        sudo macchanger <options> <interface#>
        ```
        * `-l`: Display a list of vendor MAC addresses.
        * `-r`: Choose a completely random MAC address.
        * `-m <MAC address>`: Specify the exact MAC address you want to use.
        * `-b`: Pretend to be a burned-in address (BIA).
        * `-p`: Reset to the original permanent hardware MAC address.
    3.  Bring the interface up:
        ```bash
        sudo ip link set <interface#> up
        ```

* **Retain Spoofed MAC Address Across Reboots:**
    1.  Open the NetworkManager configuration file:
        ```bash
        sudo nano /etc/NetworkManager/conf.d/retain_spoofed_mac.conf
        ```
    2.  Enter the following content into the file:
        ```ini
        [device]
        wifi.scan-rand-mac-address=no

        [connection]
        ethernet.cloned-mac-address=preserve
        wifi.cloned-mac-address=preserve
        ```

## ANDROID APPS

* **BLUETOOTH LOW ENERGY (BLE) SCANNER:**
    * **Description:** Used to identify low-energy Bluetooth devices (BLE) in the vicinity, such as Bluetooth beacons or pucks.

* **WIFI ANALYZER:**
    * **Description:** A tool for performing quick scans of Wi-Fi Access Points in the area, providing information like signal strength and channel.


# (4) Password Cracking

This section details the process of attempting to crack passwords for wireless networks and other services.

## (1) TARGET DISCOVERY

* **Command:**
    ```bash
    airodump-ng --band abg <wlan#mon>
    ```
    * **Description:** This command scans for nearby wireless networks on all supported bands (2.4 GHz and 5 GHz).
    * **Note:** Pay attention to the **PWR** (Power) column. A higher (less negative) value indicates a stronger signal, and a power level higher than -58 dBm is generally recommended for a reliable attack.

## TARGET COLLECTION

* **Command (Specific Channel):**
    ```bash
    airodump-ng -c# <wlan#mon>
    ```
    * **Description:** This command focuses the capture on a specific channel (`#`) where the target network was identified.

* **Command (Specific BSSID and Channel):**
    ```bash
    airodump-ng --bssid <BSSID> -c# <wlan#mon>
    ```
    * **Description:** This command further narrows the capture to a specific Access Point (WAP) identified by its BSSID (`<BSSID>`) and operating on a specific channel (`#`).

## PASSIVE HANDSHAKE COLLECTION

* **Command:**
    ```bash
    airodump-ng --bssid <BSSID> -c# -w <output> <wlan#mon>
    ```
    * **Description:** This command captures all traffic associated with the target network (specified by `--bssid` and `-c#`) and writes it to a file (`<output>`).
    * **Note:** Look at the top right of the `airodump-ng` output. Wait for the message "**WPA HANDSHAKE**" followed by the BSSID of the target network to appear. This indicates that a successful WPA/WPA2 handshake has been captured.

## ACTIVE COLLECTION

* **Description:** Use this method only when passive collection is not yielding a handshake (e.g., no clients actively communicating with the Access Point).

### DEAUTH ATTACK

* **Command:**
    ```bash
    aireplay-ng --deauth=(1-7) -a <BSSID_MAC> -c <CLIENT_MAC> <wlan#mon>
    ```
    * **Options:**
        * `--deauth=0`: Performs a deauthentication attack.
        * `1-7`: Specifies the number of deauthentication packets to send. It's generally recommended to send a small number of packets to avoid raising suspicion.
        * `-a <BSSID_MAC>`: Specifies the MAC address of the Access Point (BSSID). This acts as the source address of the deauthentication packets.
        * `-c <CLIENT_MAC>`: Specifies the MAC address of the client device you want to deauthenticate. You can often find client MAC addresses listed in the `airodump-ng` output under the "STATION" section. If you omit `-c`, the deauthentication packets will be broadcast, targeting all connected clients.
        * `<wlan#mon>`: The monitor mode interface.

### VERIFY THE HANDSHAKE

* **Wireshark Filter:**
    ```
    eapol
    ```
    * **Description:** Open the captured PCAP file in Wireshark and apply this filter. A successful WPA/WPA2 handshake consists of four EAPOL (Extensible Authentication Protocol over LAN) messages. Ensure all four messages are present.

## (2) GATHERING CREDENTIALS TO GET ONTO THE WIFI NETWORK

### STRIP ENCRYPTION FROM PCAP

* **Command:**
    ```bash
    airdecap-ng <options> <file.pcap>
    ```
    * **Options:**
        * `-b <BSSID>`: Specify the BSSID of the target network.
        * `-e <SSID>`: Specify the SSID of the target network.
        * `-p <passphrase>`: If you already know the passphrase, you can use this option to verify if the handshake is valid.

### METHODS TO CREATE DICTIONARY

* **hashcat:** A powerful password cracking tool with various modes and capabilities.
* **crunch:** A tool for generating custom wordlists based on specified patterns and character sets.

### AIRCRACK-NG

* **Command:**
    ```bash
    aircrack-ng -w <created-dictionary.txt> <file.pcap>
    ```
    * **Options:**
        * `-w <created-dictionary.txt>`: Specifies the path to the dictionary file you want to use for cracking.
        * `<file.pcap>`: The PCAP file containing the captured WPA/WPA2 handshake.
        * `-e=<ESSID>`: (Optional) Filter the PCAP file by a specific ESSID.
        * `-b=<BSSID>`: (Optional) Filter the PCAP file by a specific BSSID.

## (3) CONNECTING TO WIFI (WPA)

* **Create `wpa_supplicant.conf` File (Method 1 - Append):**
    ```bash
    sudo wpa_passphrase 'SSID' 'password' >> /etc/wpa_supplicant/wpa_supplicant.conf
    ```

* **Create `wpa.conf` File (Method 2 - Create New):**
    ```bash
    sudo wpa_passphrase 'SSID' 'password' > wpa.conf
    ```

* **Edit `wpa_supplicant.conf` File:**
    ```bash
    sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
    ```
    * **Hidden SSID:** If the SSID is hidden, ensure the following line is present: `scan_ssid=1`

* **Connect to Wi-Fi:**
    ```bash
    sudo wpa_supplicant -B -c <wpa.conf> -i <wlan#>
    ```

* **Request IP Address:**
    ```bash
    sudo dhclient <wlan#>
    ```

### WLAN DISCONNECTION VIA CLI

* **Release IP Address:**
    ```bash
    sudo dhclient <wlan#> -r
    ```

* **Bring Interface Down:**
    ```bash
    sudo ip link set <wlan#> down
    ```

### REMOVE/COMMENT OUT OLD WPA_SUPPLICANT FILES

* **Remove Configuration File:**
    ```bash
    sudo rm /etc/wpa_supplicant/wpa_supplicant.conf
    ```

## HYDRA

* **Description:** Hydra is a parallelized login cracker which supports numerous protocols to attack. It is often used for brute-forcing passwords for various services, including SSH.

* **Installation:**
    ```bash
    sudo apt install hydra
    ```

* **Usage (SSH Example):**
    ```bash
    hydra -l <username> -P <words.txt> <Target IP> ssh -s <PORT#>
    ```
    * `-l <username>`: Specifies the username to try.
    * `-L <username_list.txt>`: Specifies a file containing a list of usernames.
    * `-p <exact_password>`: Specifies a single password to try.
    * `-P <words.txt>`: Specifies a file containing a list of passwords (wordlist).
    * `<Target IP>`: The IP address of the target server.
    * `ssh`: The service to attack (e.g., ssh, ftp, http).
    * `-s <PORT#>`: Specifies the port number if the service is running on a non-standard port.

## CUSTOM WORDLIST GENERATOR (CeWL)

* **Description:** CeWL (Custom Word List generator) is a Ruby script which spiders a given URL to a specified depth and returns a list of words that can be used for password cracking.

* **Usage:**
    ```bash
    cewl -w <customfile.txt> -d <#> -m <#> -e <URL>
    ```
    * `-w <customfile.txt>`: Specifies the output file to save the generated wordlist.
    * `-d <#>`: Sets the depth the spider will crawl (how many links deep).
    * `-m <#>`: Sets the minimum length of words to scrape.
    * `-e <URL>`: The URL of the website to spider. This option also attempts to scrape email addresses.

## WORDLIST TRIMMING (`pw-inspector`)

* **Description:** `pw-inspector` is a tool used to analyze and manipulate wordlists, including trimming them based on minimum and maximum word lengths.

* **Usage:**
    ```bash
    pw-inspector -m <#> -M <#> -i <word.list> -o <trimmed.word.list>
    ```
    * `-m <#>`: Specifies the minimum length of words to keep.
    * `-M <#>`: Specifies the maximum length of words to keep.
    * `-i <word.list>`: The input wordlist file you want to trim.
    * `-o <trimmed.word.list>`: The output file to save the trimmed wordlist.

## CRUNCH

* **Description:** Crunch is a wordlist generator that allows you to create wordlists based on specific character sets, lengths, and patterns.

* **Usage (Basic):**
    ```bash
    crunch <min-len> <max-len> <string of characters> -o <file.txt>
    ```
    * `<min-len>`: The minimum length of the words to generate.
    * `<max-len>`: The maximum length of the words to generate.
    * `<string of characters>`: The set of characters to use in the wordlist.
    * `-o <file.txt>`: The output file to save the generated wordlist.

* **Example:**
    ```bash
    crunch 3 3 abc -o file.txt
    ```
    * Generates all possible 3-character combinations using the characters 'a', 'b', and 'c'.

* **Usage (Pattern Specification):**
    ```bash
    crunch <min-len> <max-len> -t <pattern> -o <file.txt>
    ```
    * `-t <pattern>`: Specifies a pattern to follow. Special characters used in the pattern:
        * `@`: Represents lowercase characters.
        * `,`: Represents uppercase characters.
        * `%`: Represents numbers (digits).
        * `^`: Represents symbols.

* **Example:**
    ```bash
    crunch 13 13 -t '(910)420-%%%%' -o phone_numbers.txt
    ```
    * Generates 13-character strings following the pattern "(910)420-" followed by four digits.

## HASHCAT

* **Description:** Hashcat is a powerful and advanced password recovery utility that supports various hashing algorithms and attack modes.

### IDENTIFYING HASH

* **Using `hashid`:**
    ```bash
    hashid
    ```
    * Paste the hash string when prompted.

* **Using `hash-identifier`:**
    ```bash
    hash-identifier <hash string>
    ```

* **Using `hashcat --help`:**
    ```bash
    hashcat --help | grep -i <HASH_NAME>
    ```
    * Replace `<HASH_NAME>` with keywords related to the hash you want to identify (e.g., MD5, SHA1, WPA).

### FILE LOCATIONS OF INTEREST

* **Potfile:** `$ /home/<user>/.local/share/hashcat/hashcat.potfile` (Stores cracked passwords).
* **Wordlists:** `$ /usr/share/wordlists` (Common directory for pre-made wordlists).
* **Hash Lists:** `$ /etc/shadow` (Contains user account password hashes on Linux systems - requires root privileges).
* **Brute Force Masks:** `$ /usr/share/hashcat/masks` (Pre-configured masks for brute-force attacks).
* **Hashcat Rules:** `$ /usr/share/hashcat/rules` (Rules for manipulating words in wordlists).

### CUSTOM RULE CREATION

* **Command:**
    ```bash
    nano <custom_rule_file>
    ```
* **Common Rule Syntax Examples:**
    * `:`: No operation.
    * `c`: Capitalize the first letter.
    * `$1`: Append "1" to the word.
    * `$1 $2 $3`: Append "123" to the word.
    * `c $1`: Capitalize the first letter and append "1".
    * `c $1$2$3`: Capitalize the first letter and append "123".

### HASHCAT DICTIONARY ATTACK (`-a0`)

* **Command:**
    ```bash
    hashcat -a0 -m# -D1,2 -O --force <hash.list> <wordlist.txt>
    ```
    * `-a0`: Specifies the dictionary attack mode.
    * `-m#`: Specifies the hash type (replace `#` with the hash type ID).
    * `-D1,2`: Specifies the devices to use (1 for CPU, 2 for GPU).
    * `-O`: Enables optimized kernels.
    * `--force`: Suppresses warnings.
    * `<hash.list>`: The file containing the hash(es) to crack.
    * `<wordlist.txt>`: The dictionary file to use.

### HASHCAT SINGLE LINE RULE + DICTIONARY

* **Command:**
    ```bash
    hashcat -a0 -m# -D1,2 -O --force <hash.list> <wordlist> -j '<rule>'
    ```
    * `-j '<rule>'`: Applies a single rule to each word in the wordlist.
    * `--stdout > <file.txt>`: Redirects the output (potentially cracked passwords) to a file.
    * **Example Rules:**
        * `-j 'c'`: Capitalize every password.
        * `-j 'sa@ss5soO'`: Substitute 'a' with '@', 's' with '5', and 'o' with '0'.

### MANGLING AND SORTING WORD LISTS

* **Apply Custom Rule:**
    ```bash
    hashcat -a0 <hash.list> <wordlist> -r /path/to/custom/rule --stdout > <file.txt>
    ```
    * `-r /path/to/custom/rule`: Specifies a custom rule file to mangle the wordlist.

* **Apply Single Line Rule to Existing Wordlist:**
    ```bash
    hashcat -a0 <file.txt> -j '<single line rule>' --stdout > <wordlistnew.txt>
    ```

* **Apply Rules to Modified Wordlist:**
    ```bash
    hashcat -a0 <wordlistnew.txt> -r /path/to/rules --stdout >> <wordlistnew2.txt>
    ```
    * **Note:** Use `>>` to append to the file.

* **Sort and Remove Duplicate Lines:**
    ```bash
    sort <wordlistnew2.txt> | uniq -u > <wordlist-final.txt>
    ```
    * `sort`: Sorts the wordlist.
    * `uniq -u`: Keeps only unique lines.

* **Final Hashcat Attack with Processed Wordlist:**
    ```bash
    hashcat -a0 -m# -D1,2 -O --force <hash.list> <wordlist-final.txt>
    ```

### COMBINATION ATTACK (`-a1`)

* **Command:**
    ```bash
    hashcat -a1 <word.list> <word.list> -j '#' -k '#' --stdout > <combo.list>
    ```
    * `-a1`: Specifies the combination attack mode (combines words from two wordlists).
    * `-j '#'`: Rule to apply to the left wordlist (e.g., `'c'` for capitalize).
    * `-k '#'`: Rule to apply to the right wordlist.

* **Example (Capitalize First Letter of Each Word):**
    ```bash
    hashcat -a1 <word.list> <word.list> -jc -kc --stdout > <combo.list>
    ```

* **Run Hashcat with the Combined Wordlist:**
    ```bash
    hashcat -a0 -m# -D1,2 -O --force <hash.list> <combo.list>
    ```

### BRUTE FORCE ATTACK (`-a3`)

* **Command (Basic Mask Attack):**
    ```bash
    hashcat -a3 -m# -D1,2 -O --force --username <hash.list> ?l?l?l?l -w4
    ```
    * `-a3`: Specifies the brute-force attack mode.
    * `--username`: If the hash list includes usernames.
    * `?l`: Represents lowercase characters.
    * `?u`: Represents uppercase characters.
    * `?d`: Represents digits.
    * `?s`: Represents printable special characters (including spaces).
    * `?a`: Represents all of the above (upper, lower, digits, specials).
    * `-w4`: Sets the workload profile (adjust as needed).

* **Command (Custom Character Sets):**
    ```bash
    hashcat -a3 -m# -D1,2 -O --force --username <hash.list> -1 ?u?l ?1?1?1?1?1?1
    ```
    * `-1 ?u?l`: Defines the first character set (`?1`) to include both uppercase and lowercase letters.

* **Command (Specific Special Characters):**
    ```bash
    hashcat -a3 -m# -D1,2 -O --force --username <hash.list> -1 '!@#$' ?u?l?1?1?1?1
    ```
    * `-1 '!@#$'`: Defines the first character set to include the special characters '!', '@', '#', and '$'.

* **Using Pre-configured Masks:**
    ```bash
    hashcat -a3 -m# -D1,2 -O --force --username ~/hashcat/masks/rockyou*
    ```
    * Uses masks found in the specified directory (e.g., masks derived from the RockYou wordlist).

### HYBRID ATTACK (`-a6` or `-a7`)

* **Description:** Hybrid attacks combine dictionary-based attacks with brute-force masks.
    * `-a6`: Appends the mask to each word in the wordlist.
    * `-a7`: Prepends the mask to each word in the wordlist.

* **APPEND (`-a6`):**
    ```bash
    hashcat -a6 -m# -D1,2 --username --force <hash.hash> <wordlist.txt> ?d?d?d
    ```
    * Appends three digits (`?d?d?d`) to each word in `wordlist.txt`.

* **PREPEND (`-a7`):**
    ```bash
    hashcat -a7 -m# -D1,2 --username --force <hash.hash> ?d?d?d <wordlist.txt>
    ```
    * Prepends three digits to each word in `wordlist.txt`.


# (5) Further Enumeration and Physical Penetration

This section covers additional commands for network and service enumeration, as well as techniques for physical penetration on UNIX/Debian systems.

## (1) Network Discovery (Additional Commands)

* **Ping Sweep with `fping`:**
    ```bash
    fping -a -g X.X.X.0/X 2> /dev/null
    ```
    * **Description:** Uses `fping` to identify live hosts within a specified network range (`X.X.X.0/X`). The `-a` flag shows alive hosts, and `2> /dev/null` redirects error messages.

* **ARP Scan with `arp-scan`:**
    ```bash
    sudo arp-scan -l
    ```
    * **Description:** Performs a local ARP scan to discover devices on the local network. Requires root privileges.

* **`nmap` Ping Scan and Host Discovery:**
    ```bash
    sudo nmap -sn -n -v <IP.address>/X -oG - | awk '/Up$/{print $2}'
    ```
    * **Description:** Uses `nmap` to perform a ping scan (`-sn`) on a network range (`<IP.address>/X`).
        * `-n`: Skips reverse DNS resolution.
        * `-v`: Enables verbose output.
        * `-oG -`: Outputs results in a grepable format to standard output.
        * `awk '/Up$/{print $2}'`: Filters the output to display only the IP addresses of hosts that are up.

## Network Mapping (Revisited)

* **`netdiscover` (Additional Options):**
    ```bash
    sudo netdiscover -f -r 192.168.0.1/24 -c 3 -i eth0
    ```
    * **Description:** Performs a network discovery on the specified range.
        * `-f`: Enables fast mode.
        * `-r 192.168.0.1/24`: Specifies the target network range.
        * `-c 3`: Sets the number of ARP requests to send per host to 3.
        * `-i eth0`: Specifies the network interface to use (e.g., `eth0`).

* **`fping` (Additional Options):**
    ```bash
    fping -a -r 1 -n -g 192.168.0.1/24
    ```
    * **Description:** Pings hosts on the specified network.
        * `-a`: Only shows alive hosts.
        * `-g 192.168.0.1/24`: Specifies the target network range.
        * `-r 1`: Sets the number of pings to send to each host to 1.
        * `-n`: Performs reverse DNS lookup to get hostnames from IP addresses.
        * `-h`: Prints the help menu for `fping`.

* **`nmap` Host Discovery (Detailed):**
    ```bash
    nmap -sS --top-ports 1000 -PE -PS443 -PA80 -PP 192.168.0.1/24
    ```
    * **Description:** Performs a SYN scan on the top 1000 ports and uses various ping types for host discovery on the specified network. See below for detailed host discovery options.

    ### Host Discovery Types (`nmap` `-sn` equivalent and more)

    * `-Pn`: No ping, no host discovery. Performs ARP only on local networks.
    * `-PS <portlist>`: TCP SYN packet to specified port(s) (e.g., `-PS 80`).
    * `-PA <portlist>`: TCP ACK packet to specified port(s) (e.g., `-PA 80`).
    * `-PU <portlist>`: UDP ping to specified port(s) (default is 40125). Target should respond with port unreachable if closed.
    * `-PY <portlist>`: SCTP INIT ping to specified port(s) (e.g., `-PY 80`). SCTP is a newer TCP-like protocol.
    * `-PE`: ICMP echo request (ping).
    * `-PP`: ICMP timestamp request.
    * `-PM`: ICMP subnet mask request.
    * `-PR`: ARP scan. Automatically done before any other discovery if the target is on the local network.
    * `-n`: No reverse DNS resolution (runs faster).
    * `-R`: Always perform reverse DNS resolution, even on target hosts that are not alive.
    * `--traceroute`: Perform a traceroute to the target hosts.

## (2) Service Enumeration (Additional `nmap` Commands)

* **Basic Open Port Scan:**
    ```bash
    nmap -Pn -n -v -T4 <IP.address> --open
    ```
    * **Description:** Uses `nmap` to scan for open ports (`--open`) on a target IP address (`<IP.address>`).
        * `-Pn`: Skips host discovery.
        * `-n`: Skips reverse DNS resolution.
        * `-v`: Enables verbose output.
        * `-T4`: Sets the timing template to aggressive.

* **Service Version Detection on Specific Port:**
    ```bash
    nmap -Pn -n -v -T4 -sV <IP.address> --version-all -p#
    ```
    * **Description:** Performs service version detection (`-sV` with `--version-all` for more detail) on a specific port (`-p#`) of the target IP address.

* **Advanced Scan with Scripts and Port Specification:**
    ```bash
    nmap -Pn -v -n -T4 -A/-sC/--script=XX <IP.address> -p#
    ```
    * **Description:** Performs an advanced scan using various options:
        * `-A`: Enables aggressive scan (OS detection, version detection, script scanning, traceroute).
        * `-sC`: Runs default Nmap scripts.
        * `--script=XX`: Runs a specific Nmap script or a category of scripts (replace `XX`).
        * `-p#`: Scans a specific port.

    ### Scan Types (`nmap`)

    * `-sL`: List scan (DNS lookups, no other host discovery).
    * `-sn`: No port scan, just do discovery (`-PE -PS443 -PA80 -PP` by default for privileged users).
    * `-sS`: TCP SYN scan (half-open scan, requires privileged user).
    * `-sT`: TCP connect scan (completes the three-way handshake, then sends RST).
    * `-sA`: TCP ACK scan (useful for mapping firewall rules, results in `filtered` or `unfiltered`).
    * `-sU`: UDP scan (can be slow).
    * `-sY`: SCTP port scan (SCTP is a TCP alternative, not widely used).
    * `-sN`: TCP Null scan (sends a TCP packet with no flags set, results in `closed` or `open|filtered`).
    * `-sF`: TCP FIN scan (sends a TCP FIN packet, results in `closed` or `open|filtered`).
    * `-sX`: TCP Xmas scan (sends a TCP packet with FIN, PSH, and URG flags set, results in `closed` or `open|filtered`).

    ### Port Results (`nmap`)

    * `open`: Port is open and accepting connections.
    * `closed`: Port is reachable, but no application is listening.
    * `filtered`: A firewall or other network obstacle is blocking attempts to reach the port.
    * `unfiltered`: The port is reachable, but `nmap` cannot determine if it's open or closed (typically from an ACK scan).
    * `open|filtered`: `nmap` cannot determine if the port is open or filtered (common with UDP, FIN, Null, and Xmas scans).
    * `closed|filtered`: `nmap` cannot determine if the port is closed or filtered (can occur with IP ID scan).

    ### Port Specification (`nmap`)

    * `-p <port range>`: Only scan the specified port range (e.g., `-p 1-100`, `-p 80,443,8080`).
    * `-p-`: Scan all 65,535 ports.
    * `-F`: Scan the top 100 most common ports.
    * `--top-ports <n>`: Scan the top `n` most common ports (default is 1000).

    ### Service and Version Detection (`nmap`)

    * `-sV`: Determine the version of the services running on open ports.

    ### OS Detection (`nmap`)

    * `-O`: Enable operating system detection.

    ### NSE (Nmap Scripting Engine) (`nmap`)

    * `-sC`: Perform a script scan using scripts marked as default.
    * `--script "default and safe"`: Run scripts that are both in the `default` and `safe` categories.
    * `--script "default or safe"`: Run scripts that are in either the `default` or `safe` categories.
    * `--script "not intrusive"`: Run scripts that are not considered intrusive.

        * **Categories of Scripts:** `auth`, `broadcast`, `default`, `discovery`, `dos`, `exploit`, `external`, `fuzzer`, `intrusive`, `malware`, `safe`, `version`, and `vuln`.

    ### Timing (`nmap`)

    * `-T0`: Paranoid (very slow, avoids detection).
    * `-T1`: Sneaky (slow, less likely to be detected).
    * `-T2`: Polite (slower, reduces bandwidth usage).
    * `-T3`: Normal (default timing).
    * `-T4`: Aggressive (fast, might be less accurate or more detectable on some networks).
    * `-T5`: Insane (very fast, high chance of missed ports and detection).

    ### Output to Files and Screen (`nmap`)

    * `-oN <filename>`: Normal output to the specified file.
    * `-oX <filename>`: XML output to the specified file.
    * `-oG <filename>`: Greppable output to the specified file.
    * `-oA <basename>`: Output in all three formats (normal, XML, and greppable) with the given basename.
    * `-v`: Increase verbosity (show results as they come in).
    * `-vv`: Increase verbosity further.
    * `-vvv`: Maximum verbosity.
    * `--reason`: Display the reason why a port is classified as open, closed, or filtered.
    * `--open`: Only show ports that are open or possibly open.

    ### Other (Convenience) Options (`nmap`)

    * `-A`: Enable aggressive scan options: `-O -sV -sC --traceroute`.
    * `-V`: Print the `nmap` version.
    * `-h`: Print the help page.

    ### Runtime Interaction (`nmap` while running)

    * `?`: Print a runtime help menu.
    * `v`/`V`: Increase/decrease verbosity.
    * `d`/`D`: Increase/decrease debug level.
    * `p`/`P`: Turn on/off packet tracing.
    * Any other key: Print a status message.

## (3) Common Services

This section outlines commands for enumerating common network services.

* **FTP (File Transfer Protocol)**
    * **Command (CLI):**
        ```bash
        ftp <IP.address>
        ```
        * **Anonymous Login:** Try logging in with the username `anonymous` and password `anonymous@anonymous.com` or just `anonymous`.

    * **Command (Browser):**
        ```
        ftp://<IP address/>
        ```
        * **Description:** You can often access FTP servers through a web browser.

* **HTTP/S (Hypertext Transfer Protocol/Secure)**
    * **Directory Brute-forcing with `dirb`:**
        ```bash
        dirb http://<IP.address>
        ```
        * **Description:** Uses the `dirb` tool to brute-force directories and files on a web server.

    * **Directory Brute-forcing with `gobuster`:**
        ```bash
        gobuster dir -e -u <URL/> -w <word.list>
        ```
        * **Description:** Uses `gobuster` to perform directory brute-forcing on a given URL (`<URL/>`) using a specified wordlist (`<word.list>`). The `-e` flag enables extended mode.

    * **Web Crawling with `crawlbox.py`:**
        ```bash
        python crawlbox.py <URL/> -w <word.list>
        ```
        * **Description:** Runs a Python script (`crawlbox.py`) to crawl a website (`<URL/>`) and potentially use a wordlist (`<word.list>`) for discovery.

    * **HTTP Enumeration with `nmap` Script:**
        ```bash
        nmap -Pn -v -sV --script=http-enum -p# <IP.address>
        ```
        * **Description:** Uses the `http-enum` Nmap script to enumerate common web server configurations and files on a specific port (`-p#`).

    * **Fuzzing with `ffuf`:**
        ```bash
        ffuf -c -w /usr/share/path/to/wordlist -u 'http://<IP.address>/~FUZZ'
        ```
        * **Description:** Uses the `ffuf` tool for web fuzzing.
            * `-c`: Enables colored output.
            * `-w /usr/share/path/to/wordlist`: Specifies the wordlist to use.
            * `-u 'http://<IP.address>/~FUZZ'`: The target URL with `FUZZ` as the placeholder for the fuzzed values.

* **SMB (Server Message Block)**
    * **Vulnerability Scanning with `nmap` Scripts:**
        ```bash
        nmap -Pn -n -v -T4 -sV --script="smb-vuln-ms*" -p 445 <IP.address>
        ```
        * **Description:** Uses `nmap` scripts matching the pattern `smb-vuln-ms*` to scan for common SMB vulnerabilities on port 445.

    * **SMB Enumeration with `enum4linux`:**
        ```bash
        enum4linux -v <IP.address>
        ```
        * **Description:** Uses the `enum4linux` tool to enumerate information about SMB/CIFS shares, users, groups, etc., on the target IP address.

    * **Listing Shares with `smbclient`:**
        ```bash
        smbclient -L \\\\<IP.address>
        ```
        * **Description:** Uses `smbclient` to list the shared resources on the target IP address. You might be prompted for a password; try pressing Enter for anonymous access.

## (4) Physical Penetration (UNIX/DEBIAN Systems)

This section outlines steps to gain access to a UNIX/Debian system with physical access.

1.  **Accessing GRUB Menu:**
    * Reboot the target system.
    * During the boot process, press the key combination to enter the GRUB (GNU GRand Unified Bootloader) menu (often `F11` or `F12`, but it can vary).

2.  **Highlight Advanced Options:**
    * Use the arrow keys to highlight the "Advanced options for \[OS Name]" entry.

3.  **Select Edit Mode:**
    * Press the `e` key to edit the boot parameters for the selected kernel.

4.  **Locate the Kernel Line:**
    * Scroll down to the line that starts with `Linux`.

5.  **Modify Kernel Parameters:**
    * Move the cursor to the end of the line, after the parameters `ro quiet splash` (or similar).
    * Delete the `ro quiet splash` part, stopping at the `r` in `ro`.
    * Replace `ro` with `rw init=/bin/bash`. This tells the kernel to mount the filesystem in read-write mode (`rw`) and to start a bash shell (`/bin/bash`) as the initial process instead of the regular init system.

6.  **Boot with Modified Parameters:**
    * Press `Ctrl + X` to boot the system with the modified kernel parameters. This should drop you into a root shell without requiring a password.

7.  **Change Current User Password:**
    * **List Users (Optional):**
        ```bash
        cat /etc/passwd
        ```
        * **Description:** Displays a list of users on the system.
    * **Change Password:**
        ```bash
        passwd <user.name>
        ```
        * **Description:** Replace `<user.name>` with the username whose password you want to change. You will be prompted to enter the new password.

8.  **Add a New User with Sudo Privileges:**
    * **Add User:**
        ```bash
        useradd -m -s /bin/bash <user.name>
        ```
        * **Description:** Adds a new user with a home directory (`-m`) and sets their default shell to bash (`-s /bin/bash`).
    * **Add User to Sudo Group:**
        ```bash
        usermod -aG sudo <user.name>
        ```
        * **Description:** Adds the new user to the `sudo` group, granting them administrative privileges.
    * **Set Password for New User:**
        ```bash
        passwd <user.name>
        ```
        * **Description:** Sets the password for the newly created user.

9.  **Reboot the System:**
    ```bash
    exec /sbin/init
    ```
    * **Description:** This command initiates the normal system startup process.